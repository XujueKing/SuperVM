# Phase 14 M14.2: shaderc 编译器集成

**状态**: 📋 待开始  
**优先级**: 🟡 中等（提升开发体验，非阻塞性）  
**预计时间**: 2-3 天

## 目标

将 GLSL → SPIR-V 编译流程集成到 Rust 构建系统中，实现：
1. `cargo build` 时自动检测并编译修改过的 `.comp` 文件
2. 编译产物自动验证（spirv-val）
3. 构建时检查确保源码与二进制同步

## 技术方案

### 方案 A: build.rs + shaderc-rs（推荐）✅

**优点**:

- 纯 Rust 生态，跨平台无依赖

- `shaderc-rs` crate 封装 Google shaderc

- 集成简单，维护成本低

**实现步骤**:

```rust
// build.rs
fn main() {
    let mut compiler = shaderc::Compiler::new().unwrap();
    let options = shaderc::CompileOptions::new().unwrap();
    
    // 编译所有 .comp 文件
    for shader in glob("shaders/*.comp").unwrap() {
        compile_shader(&mut compiler, &options, shader);
    }
    
    // 触发重新编译条件
    println!("cargo:rerun-if-changed=shaders/");
}

```

### 方案 B: build.rs + 外部 glslc 命令

**优点**:

- 无额外依赖

- 使用系统已安装的 Vulkan SDK

**缺点**:

- 需要用户安装 Vulkan SDK

- 跨平台路径处理复杂

- CI/CD 需要额外配置

### 方案 C: Cargo xtask 子命令

**优点**:

- 显式控制，开发者主动触发

- 可添加额外验证逻辑

**缺点**:

- 不是自动化，容易忘记执行

- 不如 build.rs 集成度高

## 推荐实现：方案 A

### 1. 添加依赖

```toml

# Cargo.toml

[build-dependencies]
shaderc = "0.8"
glob = "0.3"

[dependencies]

# ... 现有依赖

```

### 2. 创建 build.rs

```rust
// src/gpu-executor/build.rs
use std::path::Path;
use glob::glob;

fn main() {
    println!("cargo:rerun-if-changed=shaders/");
    
    let mut compiler = shaderc::Compiler::new()
        .expect("Failed to create shader compiler");
    let mut options = shaderc::CompileOptions::new()
        .expect("Failed to create compile options");
    
    // 启用优化
    options.set_optimization_level(shaderc::OptimizationLevel::Performance);
    // 目标 SPIR-V 1.3 (Vulkan 1.1+)
    options.set_target_spirv(shaderc::SpirvVersion::V1_3);
    
    for entry in glob("shaders/*.comp").expect("Failed to read shader directory") {
        let shader_path = entry.expect("Failed to get shader path");
        compile_shader(&mut compiler, &options, &shader_path);
    }
}

fn compile_shader(
    compiler: &mut shaderc::Compiler,
    options: &shaderc::CompileOptions,
    path: &Path,
) {
    let source = std::fs::read_to_string(path)
        .expect(&format!("Failed to read shader: {:?}", path));
    
    let shader_name = path.file_name().unwrap().to_str().unwrap();
    let output_path = path.with_extension("spv");
    
    println!("Compiling shader: {} → {:?}", shader_name, output_path);
    
    let binary_result = compiler.compile_into_spirv(
        &source,
        shaderc::ShaderKind::Compute,
        shader_name,
        "main",
        Some(options),
    ).expect(&format!("Failed to compile shader: {}", shader_name));
    
    // 检查编译警告
    if binary_result.get_num_warnings() > 0 {
        eprintln!("Shader compilation warnings for {}:", shader_name);
        eprintln!("{}", binary_result.get_warning_messages());
    }
    
    // 写入 SPIR-V 二进制
    std::fs::write(&output_path, binary_result.as_binary_u8())
        .expect(&format!("Failed to write SPIR-V: {:?}", output_path));
    
    println!("✓ Compiled: {:?} ({} bytes)", output_path, binary_result.as_binary_u8().len());
}

```

### 3. 可选：SPIR-V 验证

```rust
// 需要额外的 spirv-tools 集成
fn validate_spirv(spv_path: &Path) {
    use std::process::Command;
    
    let output = Command::new("spirv-val")
        .arg(spv_path)
        .output()
        .expect("Failed to run spirv-val");
    
    if !output.status.success() {
        panic!("SPIR-V validation failed for {:?}:\n{}", 
            spv_path, 
            String::from_utf8_lossy(&output.stderr));
    }
}

```

## 验收标准

1. ✅ `cargo build` 自动编译所有 `.comp` 文件
2. ✅ 修改 `.comp` 后自动触发重新编译
3. ✅ 编译产物 `.spv` 文件自动生成在 `shaders/` 目录
4. ✅ 编译错误清晰显示，阻止构建
5. ✅ CI/CD 无需额外配置（纯 Rust 依赖）
6. ⭐ 可选：SPIR-V 验证通过（spirv-val）

## 开发计划

### Day 1: 基础集成

- [ ] 添加 `shaderc` 和 `glob` 依赖

- [ ] 创建 `build.rs` 基础框架

- [ ] 实现单个 shader 编译功能

- [ ] 测试 `cargo build` 触发编译

### Day 2: 完善与验证

- [ ] 添加编译选项配置（优化级别、target SPIR-V）

- [ ] 处理编译错误与警告

- [ ] 添加增量编译逻辑（检查文件时间戳）

- [ ] 集成 SPIR-V 验证（可选）

### Day 3: 测试与文档

- [ ] 测试各种场景（首次构建、增量构建、错误处理）

- [ ] 更新 README 说明构建流程

- [ ] 添加 CI/CD 配置示例

- [ ] 文档：开发 shader 的最佳实践

## 替代方案（如果不做 M14.2）

如果暂时不实现自动化编译，至少应该：

1. **提供编译脚本**：
   ```powershell
   # scripts/compile-shaders.ps1
   glslc shaders/bls12_381_field.comp -o shaders/bls12_381_field.spv
   spirv-val shaders/bls12_381_field.spv
   ```

2. **文档说明**：
   - 在 README 中明确说明如何手动编译 shaders
   - 列出依赖工具（glslc / glslangValidator）
   - 提供故障排查指南

3. **版本控制**：
   - 将 `.spv` 文件提交到仓库（确保可用性）
   - 添加注释说明生成日期和源码版本

## 建议决策

### 🟢 推荐现在实现 M14.2

**理由**:

- 注：当前进度更新为 95%（M14.2 已完成）。

- 提升后续 shader 开发效率（后续会有更多 shaders：MSM, FFT 等）

- 为团队协作打下基础（避免"Works on my machine"）

- CI/CD 友好，自动化测试更可靠

### 🟡 可推迟到 Phase 15

**条件**:

- 当前 shader 已稳定，短期不修改

- 优先完成 M14.7 文档与审查

- 后续需要开发新 shader 时再补齐

## 实施建议

**如果现在做**:
1. 立即开始 M14.2（2-3 天）
2. 之后完成 M14.7（文档审查，1 周）
3. Phase 14 达到 **98-100%** 完成度

**如果推迟**:
1. 先完成 M14.7（1 周）
2. Phase 14 标记为 **95% 完成**（M14.2 已补齐）
3. 在 Phase 15 启动时补齐 M14.2

---

**我的建议**: 🟢 **现在实现 M14.2**，理由是：

- 投入小（2-3 天），收益大（长期开发效率）

- 完成后 Phase 14 可以真正达到"完成"状态

- 为后续 MSM/FFT shader 开发铺平道路

你希望现在开始 M14.2 吗？我可以立即帮你搭建 build.rs 和测试！
