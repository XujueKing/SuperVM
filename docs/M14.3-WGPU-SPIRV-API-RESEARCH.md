# M14.3: WGPU SPIR-V API 调研报告

**生成时间**: 2025-11-13  
**任务**: 确定wgpu 27.0.1加载SPIR-V二进制的可行路径

---

## 1. 问题陈述

### 核心需求

- 加载预编译的`bls12_381_field.spv` (使用u64指令)

- 绕过Naga验证限制(不支持u64类型)

- 在Vulkan/DX12/Metal后端执行BLS12-381字段运算

### 当前挑战

```rust
// 在wgpu 27.0.1中不存在以下API:
device.create_shader_module_spirv(&wgpu::ShaderModuleDescriptorSpirV { ... })
                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                  找不到此类型

```

---

## 2. 调研结果

### 2.1 wgpu API历史变更

#### wgpu < 0.18 (旧版)

```rust
// 曾经支持直接SPIR-V加载
unsafe fn create_shader_module_spirv(&self, desc: &ShaderModuleDescriptorSpirV) -> ShaderModule;

```

#### wgpu >= 0.18 (当前)

- **移除原因**: 安全性和跨平台一致性考虑

- **官方推荐**: 使用WGSL或naga编译器处理SPIR-V

- **限制**: naga不支持u64类型 → 死锁

### 2.2 当前架构约束

从现有代码分析(基于搜索结果):

```rust
// src/gpu-executor/Cargo.toml
spirv = ["wgpu", "pollster", "bytemuck"]  // 无unsafe_api等特殊feature

```

```rust
// 现有WGSL加载方式(Phase 13密码学/Merkle树)
let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
    label: Some("Shader Name"),
    source: wgpu::ShaderSource::Wgsl(include_str!("shader.wgsl").into()),
});

```

---

## 3. 可行解决方案

### 方案A: 使用naga SPIR-V前端 (验证失败)

**思路**: 利用naga的`spv::Front`模块解析SPIR-V

```rust
use naga::front::spv;

let spirv_bytes = include_bytes!("bls12_381_field.spv");
let spirv_u32 = bytemuck::cast_slice::<u8, u32>(spirv_bytes);

let options = spv::Options::default();
let module = spv::parse_u32_slice(spirv_u32, &options)?;

// 将naga::Module转为WGSL (可能丢失u64)
let wgsl_string = naga::back::wgsl::write_string(&module, &wgsl_options)?;

```

**致命缺陷**:  
❌ naga解析会验证SPIR-V → 遇到u64指令立即报错  
❌ 即使绕过解析,后端生成WGSL时会去除u64类型

---

### 方案B: 直接使用底层图形API (推荐⭐)

#### B1. Vulkan Backend (via `ash` crate)

```rust
use ash::vk;

// 1. 跳过wgpu,直接创建Vulkan对象
let entry = ash::Entry::linked();
let instance = entry.create_instance(&vk::InstanceCreateInfo::default(), None)?;
let device = ...; // 创建逻辑设备

// 2. 加载SPIR-V
let spirv_bytes = include_bytes!("bls12_381_field.spv");
let shader_info = vk::ShaderModuleCreateInfo::builder()
    .code(bytemuck::cast_slice::<u8, u32>(spirv_bytes));

let shader_module = unsafe {
    device.create_shader_module(&shader_info, None)?
};

// 3. 创建计算管线
let pipeline_info = vk::ComputePipelineCreateInfo::builder()
    .stage(vk::PipelineShaderStageCreateInfo::builder()
        .stage(vk::ShaderStageFlags::COMPUTE)
        .module(shader_module)
        .name(CStr::from_bytes_with_nul_unchecked(b"main\0"))
        .build())
    .layout(pipeline_layout);

let pipeline = unsafe {
    device.create_compute_pipelines(vk::PipelineCache::null(), &[pipeline_info.build()], None)?
        .into_iter().next().unwrap()
};

```

**优势**:  
✅ 完全控制SPIR-V加载(无验证)  
✅ 原生支持u64指令  
✅ 高性能(零开销抽象)

**劣势**:  
❌ 失去wgpu跨平台抽象  
❌ 仅支持Vulkan后端(需要Metal/DX12则需额外实现)  
❌ 复杂的生命周期管理(device, queue, fences等)

#### B2. Metal Backend (via `metal` crate)

```rust
use metal::*;

let device = Device::system_default().unwrap();

// Metal使用MSL(Metal Shading Language)或预编译的AIR/metallib
// 需要先将SPIR-V转为MSL
let library = device.new_library_with_data(msl_source)?;
let function = library.get_function("main", None)?;
let pipeline = device.new_compute_pipeline_state_with_function(&function)?;

```

**注意**: Metal不直接支持SPIR-V,需要额外转换步骤(SPIRV-Cross)

---

### 方案C: 等待wgpu upstream支持 (长期)

**追踪Issue**: [gfx-rs/wgpu#1096](https://github.com/gfx-rs/wgpu/issues/1096)  
**状态**: 讨论中,无明确时间表  
**风险**: 可能永久不支持(官方倾向于WGSL统一)

---

## 4. 推荐实施方案

### 混合架构: wgpu + Vulkan Fallback

```rust
// src/gpu-executor/src/spirv/executor.rs

pub enum SpirvExecutor {
    /// 尝试使用wgpu(如果未来支持)
    Wgpu(WgpuSpirvBackend),
    
    /// Vulkan原生后端(当前主要路径)
    Vulkan(VulkanSpirvBackend),
    
    /// Metal原生后端(macOS)
    Metal(MetalSpirvBackend),
}

impl SpirvExecutor {
    pub fn new() -> Result<Self, ExecError> {
        // 优先级: wgpu > native backend
        if cfg!(feature = "wgpu-spirv-experimental") {
            // 预留未来wgpu支持的入口
            return Ok(Self::Wgpu(WgpuSpirvBackend::new()?));
        }
        
        #[cfg(target_os = "linux")]
        return Ok(Self::Vulkan(VulkanSpirvBackend::new()?));
        
        #[cfg(target_os = "macos")]
        return Ok(Self::Metal(MetalSpirvBackend::new()?));
        
        #[cfg(target_os = "windows")]
        return Ok(Self::Vulkan(VulkanSpirvBackend::new()?)); // 或DX12
    }
}

```

### 实现优先级

#### Phase 1: Vulkan最小可行实现 (1-2天)

```rust
// src/gpu-executor/src/spirv/vulkan_backend.rs

use ash::vk;

pub struct VulkanSpirvBackend {
    _entry: ash::Entry,
    instance: ash::Instance,
    device: ash::Device,
    queue: vk::Queue,
    command_pool: vk::CommandPool,
}

impl VulkanSpirvBackend {
    pub fn new() -> Result<Self, ExecError> {
        // 1. 创建Vulkan实例
        // 2. 选择物理设备(支持compute queue)
        // 3. 创建逻辑设备
        // 4. 创建命令池
        todo!()
    }
    
    pub fn execute_bls12_381_field_add(
        &mut self,
        input_a: &[[u64; 6]],
        input_b: &[[u64; 6]],
    ) -> Result<Vec<[u64; 6]>, ExecError> {
        // 1. 创建buffer(input_a, input_b, output)
        // 2. 加载bls12_381_field.spv
        // 3. 创建计算管线
        // 4. 录制命令缓冲区
        // 5. 提交执行
        // 6. 读回结果
        todo!()
    }
}

```

**验证标准**:

- ✅ 加载`bls12_381_field.spv`成功

- ✅ 执行field_add在256K元素上

- ✅ 结果与CPU golden vectors一致(19组测试)

#### Phase 2: 跨平台抽象 (0.5-1天)

```rust
pub trait SpirvBackend {
    fn load_shader(&mut self, spirv: &[u32], entry: &str) -> Result<ShaderHandle, ExecError>;
    fn create_buffer(&mut self, size: usize, usage: BufferUsage) -> Result<BufferHandle, ExecError>;
    fn dispatch(&mut self, shader: ShaderHandle, workgroups: [u32; 3]) -> Result<(), ExecError>;
    fn read_buffer(&self, buffer: BufferHandle) -> Result<Vec<u8>, ExecError>;
}

impl SpirvBackend for VulkanSpirvBackend { ... }
impl SpirvBackend for MetalSpirvBackend { ... }

```

---

## 5. 依赖项更新

### Cargo.toml修改

```toml
[dependencies]

# Phase 14 M14.3: Native Vulkan backend for SPIR-V

ash = { version = "0.38", optional = true }

# Optional: SPIRV-Cross for Metal backend

spirv-cross = { version = "0.26", optional = true, features = ["metal"] }

[features]

# 原生SPIR-V后端(需要Vulkan或Metal)

spirv-vulkan = ["ash"]
spirv-metal = ["spirv-cross"]
spirv = ["spirv-vulkan"] # 默认使用Vulkan

```

---

## 6. 风险评估

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| Vulkan驱动兼容性 | 中 | 低 | 要求Vulkan 1.2+ (广泛支持u64) |
| 复杂度增加 | 高 | 中 | 限制于BLS12-381场景,不扩展通用API |
| 跨平台测试负担 | 中 | 高 | CI仅测试Linux Vulkan,其他平台手动验证 |
| 维护成本 | 中 | 中 | 文档化Vulkan流程,使用unsafe隔离 |

---

## 7. 下一步行动

### 即时任务 (M14.3-Day1)

1. [x] 完成此调研报告
2. [ ] 添加`ash`依赖到Cargo.toml
3. [ ] 创建`src/gpu-executor/src/spirv/vulkan_backend.rs`骨架
4. [ ] 实现Vulkan实例和设备初始化
5. [ ] 验证ash API可用性(编译通过)

### 短期任务 (M14.3-Day2~3)

- [ ] 实现buffer管理(VkBuffer创建/映射)

- [ ] 加载`bls12_381_field.spv`并创建ShaderModule

- [ ] 创建计算管线(VkPipeline)

- [ ] 录制和提交命令缓冲区

- [ ] 读回结果并验证正确性

### 中期任务 (M14.3-Day4~5)

- [ ] 性能优化(批量提交,异步执行)

- [ ] 完善错误处理

- [ ] 添加单元测试和集成测试

- [ ] 更新文档和示例

---

## 8. 参考资料

### Vulkan学习资源

- [Vulkan Tutorial](https://vulkan-tutorial.com/) - 图形管线为主,但基础概念通用

- [Vulkan Compute Examples](https://github.com/SaschaWillems/Vulkan) - 计算着色器示例

- [ash Documentation](https://docs.rs/ash/latest/ash/) - Rust Vulkan绑定

### SPIR-V规范

- [SPIR-V Specification](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html)

- [GLSL to SPIR-V Mapping](https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/SPV_KHR_vulkan_memory_model.txt)

### 替代方案

- [wgpu-native](https://github.com/gfx-rs/wgpu-native) - C API可能提供SPIR-V入口

- [SPIRV-Cross](https://github.com/KhronosGroup/SPIRV-Cross) - SPIR-V到MSL/HLSL转换器

---

## 9. 决策总结

✅ **采用方案B1: 直接使用ash实现Vulkan后端**

**理由**:
1. 技术可行性最高(无依赖wgpu不确定性)
2. 性能最优(零抽象开销)
3. 实现周期可控(3-5天首次实现)
4. 与现有wgpu代码隔离,风险可控

**时间预算**:

- M14.3总计: 3-5天

- Vulkan后端: 2-3天

- 集成测试: 1天

- 文档和优化: 1天

**验收标准**:

- 在Vulkan后端上运行全部19个BLS12-381测试用例

- GPU吞吐量 > 10x CPU baseline

- 代码覆盖率 > 80%

---

**报告生成**: M14.3自动化系统  
**审核状态**: 待技术负责人确认  
**更新日志**: 初始版本(2025-11-13)
