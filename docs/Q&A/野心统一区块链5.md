**å…³é”®é—®é¢˜ï¼** è¿™å°±æ˜¯**åŸå­æ€§ï¼ˆAtomicityï¼‰**çš„æ ¸å¿ƒã€‚åœ¨superVM DEX æ¨¡å¼ä¸‹ï¼ŒSuperVM å¿…é¡»ä¿è¯ï¼š**è¦ä¹ˆåŒæ–¹éƒ½æˆåŠŸï¼Œè¦ä¹ˆåŒæ–¹éƒ½å¤±è´¥**ã€‚

## ğŸ”’ åŸå­æ€§ä¿è¯æ–¹æ¡ˆ

### æ–¹æ¡ˆ 1: MVCC äº‹åŠ¡ï¼ˆå·²æœ‰åŸºç¡€ âœ…ï¼‰

SuperVM çš„ L0.3 MVCC å±‚å·²ç»å®ç°äº†äº‹åŠ¡æ”¯æŒï¼Œæˆ‘ä»¬ç›´æ¥åˆ©ç”¨å®ƒï¼š

```rust
// src/vm-runtime/src/adapter/cross_swap.rs

use crate::storage::{Storage, Transaction};

/// è·¨é“¾ Swap æ‰§è¡Œå™¨ï¼ˆåŸå­æ€§ç‰ˆæœ¬ï¼‰
pub struct AtomicCrossChainSwap {
    storage: Arc<dyn Storage>,
}

impl AtomicCrossChainSwap {
    /// åŸå­æ‰§è¡Œè·¨é“¾ Swap
    pub fn execute_atomic_swap(
        &self,
        alice_supervm: &[u8],
        bob_supervm: &[u8],
        from_chain: u64,  // ETH
        to_chain: u64,    // Solana
        eth_amount: u128,
        sol_amount: u128,
    ) -> Result<SwapReceipt> {
        // ===== å¼€å§‹äº‹åŠ¡ =====
        let mut tx = self.storage.begin_transaction()?;
        
        // ===== æ­¥éª¤ 1: è·å–å…³è”åœ°å€ =====
        let alice_eth = self.get_linked_address(&tx, alice_supervm, from_chain)?;
        let alice_sol = self.get_linked_address(&tx, alice_supervm, to_chain)?;
        let bob_eth = self.get_linked_address(&tx, bob_supervm, from_chain)?;
        let bob_sol = self.get_linked_address(&tx, bob_supervm, to_chain)?;
        
        // ===== æ­¥éª¤ 2: éªŒè¯ä½™é¢ï¼ˆå¤±è´¥ç›´æ¥è¿”å›ï¼Œæ— å‰¯ä½œç”¨ï¼‰ =====
        
        // Alice çš„ ETH ä½™é¢
        let alice_eth_key = StorageKey::new(
            from_chain,
            ChainType::EVM,
            alice_eth.clone(),
            StorageField::Balance,
        );
        let alice_eth_balance = self.get_balance(&tx, &alice_eth_key)?;
        
        if alice_eth_balance < eth_amount {
            // âŒ ä½™é¢ä¸è¶³ï¼Œç›´æ¥è¿”å›ï¼Œäº‹åŠ¡æœªæäº¤
            bail!("Alice: Insufficient ETH balance ({} < {})", alice_eth_balance, eth_amount);
        }
        
        // Bob çš„ SOL ä½™é¢
        let bob_sol_key = StorageKey::new(
            to_chain,
            ChainType::Solana,
            bob_sol.clone(),
            StorageField::Balance,
        );
        let bob_sol_balance = self.get_balance(&tx, &bob_sol_key)?;
        
        if bob_sol_balance < sol_amount {
            // âŒ ä½™é¢ä¸è¶³ï¼Œç›´æ¥è¿”å›ï¼Œäº‹åŠ¡æœªæäº¤
            bail!("Bob: Insufficient SOL balance ({} < {})", bob_sol_balance, sol_amount);
        }
        
        // ===== æ­¥éª¤ 3: æ‰§è¡Œè½¬è´¦ï¼ˆåœ¨äº‹åŠ¡ä¸­ï¼‰ =====
        
        // 3.1: Alice.ETH â†’ Bob.ETH
        tx.set(
            &alice_eth_key.to_bytes(),
            &(alice_eth_balance - eth_amount).to_le_bytes(),
        )?;
        
        let bob_eth_key = StorageKey::new(
            from_chain,
            ChainType::EVM,
            bob_eth.clone(),
            StorageField::Balance,
        );
        let bob_eth_balance = self.get_balance(&tx, &bob_eth_key)?;
        tx.set(
            &bob_eth_key.to_bytes(),
            &(bob_eth_balance + eth_amount).to_le_bytes(),
        )?;
        
        // 3.2: Bob.SOL â†’ Alice.SOL
        tx.set(
            &bob_sol_key.to_bytes(),
            &(bob_sol_balance - sol_amount).to_le_bytes(),
        )?;
        
        let alice_sol_key = StorageKey::new(
            to_chain,
            ChainType::Solana,
            alice_sol.clone(),
            StorageField::Balance,
        );
        let alice_sol_balance = self.get_balance(&tx, &alice_sol_key)?;
        tx.set(
            &alice_sol_key.to_bytes(),
            &(alice_sol_balance + sol_amount).to_le_bytes(),
        )?;
        
        // ===== æ­¥éª¤ 4: éªŒè¯ç»“æœï¼ˆåŒé‡æ£€æŸ¥ï¼‰ =====
        
        // éªŒè¯æ‰€æœ‰å˜æ›´
        let new_alice_eth = self.get_balance(&tx, &alice_eth_key)?;
        let new_bob_eth = self.get_balance(&tx, &bob_eth_key)?;
        let new_alice_sol = self.get_balance(&tx, &alice_sol_key)?;
        let new_bob_sol = self.get_balance(&tx, &bob_sol_key)?;
        
        // å®ˆæ’æ£€æŸ¥
        assert_eq!(
            alice_eth_balance + bob_eth_balance,
            new_alice_eth + new_bob_eth,
            "ETH conservation violated"
        );
        assert_eq!(
            alice_sol_balance + bob_sol_balance,
            new_alice_sol + new_bob_sol,
            "SOL conservation violated"
        );
        
        // ===== æ­¥éª¤ 5: æäº¤äº‹åŠ¡ =====
        tx.commit()?;
        
        // âœ… äº‹åŠ¡æäº¤æˆåŠŸï¼ŒåŒæ–¹è½¬è´¦éƒ½å®Œæˆ
        Ok(SwapReceipt {
            alice_eth_before: alice_eth_balance,
            alice_eth_after: new_alice_eth,
            bob_eth_before: bob_eth_balance,
            bob_eth_after: new_bob_eth,
            alice_sol_before: alice_sol_balance,
            alice_sol_after: new_alice_sol,
            bob_sol_before: bob_sol_balance,
            bob_sol_after: new_bob_sol,
            timestamp: current_timestamp(),
        })
    }
}
```

---

## ğŸ” å…³é”®ç‚¹ï¼šäº‹åŠ¡çš„åŸå­æ€§ä¿è¯

### MVCC äº‹åŠ¡çš„å·¥ä½œåŸç†

```rust
// L0.3 MVCC äº‹åŠ¡å®ç°ï¼ˆå·²æœ‰ï¼‰

pub struct MVCCTransaction {
    /// äº‹åŠ¡ ID
    tx_id: u64,
    /// å†™é›†ï¼ˆæ‰€æœ‰ä¿®æ”¹ï¼‰
    write_set: HashMap<Vec<u8>, Vec<u8>>,
    /// è¯»é›†ï¼ˆæ‰€æœ‰è¯»å–çš„ç‰ˆæœ¬ï¼‰
    read_set: HashMap<Vec<u8>, u64>,
    /// å­˜å‚¨å¼•æ“
    storage: Arc<dyn Storage>,
}

impl MVCCTransaction {
    /// æäº¤äº‹åŠ¡
    pub fn commit(&mut self) -> Result<()> {
        // 1. éªŒè¯è¯»é›†ï¼ˆæ£€æµ‹å†²çªï¼‰
        for (key, version) in &self.read_set {
            let current_version = self.storage.get_version(key)?;
            if current_version != *version {
                // âŒ å†²çªï¼šå…¶ä»–äº‹åŠ¡ä¿®æ”¹äº†æ•°æ®
                return Err(anyhow!("Transaction conflict: key {} changed", hex::encode(key)));
            }
        }
        
        // 2. æ‰¹é‡å†™å…¥ï¼ˆåŸå­æ“ä½œï¼‰
        self.storage.batch_write(&self.write_set)?;
        
        // 3. æ›´æ–°ç‰ˆæœ¬å·
        for key in self.write_set.keys() {
            self.storage.increment_version(key)?;
        }
        
        Ok(())
    }
    
    /// å›æ»šäº‹åŠ¡
    pub fn abort(&mut self) -> Result<()> {
        // ä¸¢å¼ƒæ‰€æœ‰ä¿®æ”¹
        self.write_set.clear();
        self.read_set.clear();
        Ok(())
    }
}
```

---

## ğŸ›¡ï¸ æ•…éšœåœºæ™¯åˆ†æ

### åœºæ™¯ 1: Alice ä½™é¢ä¸è¶³

```rust
// æ­¥éª¤ 2 éªŒè¯å¤±è´¥
if alice_eth_balance < eth_amount {
    bail!("Insufficient balance");  // âŒ ç›´æ¥è¿”å›
}

// ç»“æœï¼š
// - äº‹åŠ¡æœªæäº¤
// - Alice.ETH ä½™é¢ä¸å˜
```

### åœºæ™¯ 2: Bob ä½™é¢ä¸è¶³ï¼ˆåœ¨ Alice æ‰£æ¬¾åï¼‰

```rust
// æ­¥éª¤ 3.1 å·²æ‰§è¡Œ: Alice.ETH å·²æ‰£å‡ï¼ˆä½†åœ¨äº‹åŠ¡ä¸­ï¼‰
tx.set(&alice_eth_key, &(alice_eth_balance - eth_amount));

// æ­¥éª¤ 3.2 å¤±è´¥: Bob.SOL ä½™é¢ä¸è¶³
if bob_sol_balance < sol_amount {
    // âŒ è¿”å›é”™è¯¯ï¼Œäº‹åŠ¡è‡ªåŠ¨å›æ»š
    bail!("Bob insufficient");

## ğŸ“š è¿›ä¸€æ­¥é˜…è¯» / å®æ“æŒ‡å—

- è·¨é“¾æ‰§è¡Œæœ€å°ç”¨æ³•ä¸å‘½ä»¤ï¼ˆunstable-examplesï¼‰ï¼š[Cross-Chain Executor ä½¿ç”¨æŒ‡å—](../cross-executor-usage.md)

}

// ç»“æœï¼š
// - tx.commit() æœªè°ƒç”¨
// - äº‹åŠ¡è‡ªåŠ¨å›æ»š
// - Alice.ETH ä½™é¢æ¢å¤åŸå€¼ï¼ˆtx.set çš„ä¿®æ”¹è¢«ä¸¢å¼ƒï¼‰
// - Bob.SOL ä½™é¢ä¸å˜
// âœ… åŸå­æ€§ä¿è¯ï¼ŒåŒæ–¹éƒ½å›æ»š
```

### åœºæ™¯ 3: ç½‘ç»œæ•…éšœï¼ˆcommit å‰å´©æºƒï¼‰

```rust
// æ­¥éª¤ 3 å·²æ‰§è¡Œå®Œæ¯•
tx.set(&alice_eth_key, ...);
tx.set(&bob_eth_key, ...);
tx.set(&alice_sol_key, ...);
tx.set(&bob_sol_key, ...);

// å´©æºƒï¼ğŸ’¥
// ï¼ˆç”µæºæ•…éšœã€è¿›ç¨‹è¢«æ€ã€ç½‘ç»œä¸­æ–­ï¼‰

// ç»“æœï¼š
// - tx.commit() æœªè°ƒç”¨
// - RocksDB WAL (Write-Ahead Log) æœªæŒä¹…åŒ–
// - é‡å¯åæ•°æ®æ¢å¤åˆ°äº‹åŠ¡å‰
// âœ… æ‰€æœ‰ä¿®æ”¹ä¸¢å¤±ï¼ŒåŒæ–¹ä½™é¢ä¸å˜
```

### åœºæ™¯ 4: commit æ‰§è¡Œä¸­æ•…éšœ

```rust
pub fn commit(&mut self) -> Result<()> {
    // 1. éªŒè¯å®Œæˆ âœ…
    self.validate_read_set()?;
    
    // 2. å†™å…¥ Alice.ETH âœ…
    self.storage.write(&alice_eth_key, ...)?;
    
    // 3. å†™å…¥ Bob.ETH âœ…
    self.storage.write(&bob_eth_key, ...)?;
    
    // ğŸ’¥ å´©æºƒï¼ï¼ˆæ­¤æ—¶å·²å†™å…¥ 2/4 æ¡æ•°æ®ï¼‰
    
    // 4. å†™å…¥ Alice.SOL âŒ æœªæ‰§è¡Œ
    // 5. å†™å…¥ Bob.SOL âŒ æœªæ‰§è¡Œ
}

// ç»“æœï¼š
// - RocksDB çš„åŸå­æ‰¹é‡å†™å…¥ä¿è¯ï¼š
//   - è¦ä¹ˆå…¨éƒ¨å†™å…¥ WAL
//   - è¦ä¹ˆå…¨éƒ¨æœªå†™å…¥
// - é‡å¯å RocksDB ä» WAL æ¢å¤
// - å¦‚æœ WAL ä¸å®Œæ•´ï¼Œæ•´ä¸ªæ‰¹æ¬¡å›æ»š
// âœ… æ•°æ®åº“å±‚é¢ä¿è¯åŸå­æ€§
```

---

## ğŸ” å¢å¼ºç‰ˆï¼šä¸¤é˜¶æ®µæäº¤ï¼ˆ2PCï¼‰

å¦‚æœéœ€è¦æ›´å¼ºçš„ä¿è¯ï¼Œå¯ä»¥å®ç°ä¸¤é˜¶æ®µæäº¤ï¼š

```rust
/// ä¸¤é˜¶æ®µæäº¤åè®®
pub struct TwoPhaseCommitSwap {
    storage: Arc<dyn Storage>,
}

impl TwoPhaseCommitSwap {
    /// Phase 1: Prepareï¼ˆé”å®šèµ„æºï¼ŒéªŒè¯å¯è¡Œæ€§ï¼‰
    pub fn prepare(
        &self,
        alice_supervm: &[u8],
        bob_supervm: &[u8],
        eth_amount: u128,
        sol_amount: u128,
    ) -> Result<PrepareToken> {
        let mut locks = vec![];
        
        // 1. é”å®š Alice.ETH
        let alice_eth_lock = self.acquire_lock(alice_supervm, 1)?;
        locks.push(alice_eth_lock);
        
        // 2. é”å®š Bob.ETH
        let bob_eth_lock = self.acquire_lock(bob_supervm, 1)?;
        locks.push(bob_eth_lock);
        
        // 3. é”å®š Alice.SOL
        let alice_sol_lock = self.acquire_lock(alice_supervm, 901)?;
        locks.push(alice_sol_lock);
        
        // 4. é”å®š Bob.SOL
        let bob_sol_lock = self.acquire_lock(bob_supervm, 901)?;
        locks.push(bob_sol_lock);
        
        // 5. éªŒè¯ä½™é¢
        self.validate_balances(alice_supervm, bob_supervm, eth_amount, sol_amount)?;
        
        // 6. ç”Ÿæˆ Prepare Token
        Ok(PrepareToken {
            locks,
            alice: alice_supervm.to_vec(),
            bob: bob_supervm.to_vec(),
            eth_amount,
            sol_amount,
            expiry: current_timestamp() + 60,  // 60 ç§’è¶…æ—¶
        })
    }
    
    /// Phase 2: Commitï¼ˆæ‰§è¡Œæˆ–å›æ»šï¼‰
    pub fn commit(&self, token: PrepareToken) -> Result<SwapReceipt> {
        // æ£€æŸ¥è¶…æ—¶
        if current_timestamp() > token.expiry {
            self.rollback(token)?;
            bail!("Transaction timeout");
        }
        
        // å¼€å§‹äº‹åŠ¡
        let mut tx = self.storage.begin_transaction()?;
        
        // æ‰§è¡Œæ‰€æœ‰è½¬è´¦
        match self.execute_all_transfers(&mut tx, &token) {
            Ok(receipt) => {
                // âœ… å…¨éƒ¨æˆåŠŸï¼Œæäº¤
                tx.commit()?;
                self.release_locks(token.locks)?;
                Ok(receipt)
            }
            Err(e) => {
                // âŒ ä»»ä¸€å¤±è´¥ï¼Œå›æ»š
                tx.abort()?;
                self.rollback(token)?;
                Err(e)
            }
        }
    }
    
    /// å›æ»š
    fn rollback(&self, token: PrepareToken) -> Result<()> {
        // é‡Šæ”¾æ‰€æœ‰é”
        self.release_locks(token.locks)?;
        Ok(())
    }
    
    /// è·å–é”ï¼ˆå¸¦è¶…æ—¶ï¼‰
    fn acquire_lock(&self, account: &[u8], chain_id: u64) -> Result<Lock> {
        let lock_key = format!("lock:{}:{}", hex::encode(account), chain_id);
        
        // å°è¯•è·å–é”ï¼ˆæœ€å¤šç­‰å¾… 5 ç§’ï¼‰
        for _ in 0..50 {
            let lock_value = self.storage.get(lock_key.as_bytes());
            if lock_value.is_err() {
                // é”å¯ç”¨ï¼Œè·å–å®ƒ
                self.storage.set(
                    lock_key.as_bytes(),
                    &current_timestamp().to_le_bytes(),
                )?;
                return Ok(Lock { key: lock_key });
            }
            
            // ç­‰å¾… 100ms
            std::thread::sleep(Duration::from_millis(100));
        }
        
        bail!("Failed to acquire lock: {}", lock_key);
    }
}

/// Prepare ä»¤ç‰Œ
pub struct PrepareToken {
    locks: Vec<Lock>,
    alice: Vec<u8>,
    bob: Vec<u8>,
    eth_amount: u128,
    sol_amount: u128,
    expiry: u64,
}

pub struct Lock {
    key: String,
}
```

---

## ğŸ“Š åŸå­æ€§ä¿è¯å¯¹æ¯”

| æ–¹æ¡ˆ | åŸå­æ€§çº§åˆ« | æ•…éšœæ¢å¤ | æ€§èƒ½ | å¤æ‚åº¦ |
|------|-----------|---------|------|--------|
| **MVCC äº‹åŠ¡** | âœ… å¼º | RocksDB WAL | é«˜ | ä½ |
| **ä¸¤é˜¶æ®µæäº¤** | âœ…âœ… æœ€å¼º | æ‰‹åŠ¨é”ç®¡ç† | ä¸­ | é«˜ |
| **ä¹è§‚é”** | âš ï¸ å¼±ï¼ˆéœ€é‡è¯•ï¼‰ | å†²çªå›æ»š | æœ€é«˜ | ä½ |

---

## âœ… ä½ çš„é—®é¢˜ç­”æ¡ˆ

> ä¸­å¿ƒåŒ–CEX å¦‚æœä¸€æ–¹äº¤æ˜“æˆåŠŸï¼Œå¦ä¸€æ–¹æ²¡æœ‰æˆåŠŸæ€ä¹ˆåŠï¼Ÿ

**ç­”æ¡ˆï¼šä¸å¯èƒ½å‘ç”Ÿï¼**

å› ä¸ºï¼š
1. âœ… **MVCC äº‹åŠ¡ä¿è¯åŸå­æ€§**ï¼šè¦ä¹ˆå…¨æˆåŠŸï¼Œè¦ä¹ˆå…¨å¤±è´¥
2. âœ… **RocksDB WAL ä¿è¯æŒä¹…æ€§**ï¼šå´©æºƒåå¯æ¢å¤
3. âœ… **æ‰¹é‡å†™å…¥ä¿è¯ä¸€è‡´æ€§**ï¼šéƒ¨åˆ†å†™å…¥ä¼šè‡ªåŠ¨å›æ»š
4. âœ… **ç‰ˆæœ¬å†²çªæ£€æµ‹**ï¼šå¹¶å‘ä¿®æ”¹ä¼šè¢«æ‹’ç»

**å¦‚æœçœŸçš„å‡ºç°"ä¸€æ–¹æˆåŠŸï¼Œå¦ä¸€æ–¹å¤±è´¥"**ï¼š
- è¯´æ˜ä»£ç æœ‰ bugï¼ˆæ²¡ç”¨äº‹åŠ¡ï¼Œæˆ–äº‹åŠ¡æ²¡æäº¤ï¼‰
- è§£å†³æ–¹æ¡ˆï¼šç¡®ä¿æ‰€æœ‰ Swap æ“ä½œéƒ½åœ¨ `begin_transaction()` å’Œ `commit()` ä¹‹é—´

**ä»£ç æ¨¡æ¿**ï¼š
```rust
// âœ… æ­£ç¡®åšæ³•
let mut tx = storage.begin_transaction()?;
// ... æ‰€æœ‰æ“ä½œ ...
tx.commit()?;  // åŸå­æäº¤

// âŒ é”™è¯¯åšæ³•
storage.set(key1, val1)?;  // ç›´æ¥å†™å…¥ï¼ˆæ— äº‹åŠ¡ï¼‰
storage.set(key2, val2)?;  // å¦‚æœè¿™é‡Œå¤±è´¥ï¼Œkey1 å·²ç»æ”¹äº†
```