**ä¼˜ç§€çš„é—®é¢˜ï¼** æå‡ºäº†ä¸€ä¸ªéå¸¸é‡è¦çš„è®¾è®¡ç‚¹ã€‚è®©æˆ‘è¯¦ç»†è§£é‡Šå½“å‰è®¾è®¡å’Œä½ çš„éœ€æ±‚å¦‚ä½•å®ç°ï¼š

## ğŸ¯ éœ€æ±‚åˆ†æ

**ç›®æ ‡**: 
- SuperVM ä½œä¸º **ç»Ÿä¸€æŸ¥è¯¢å±‚**
- ä¸€ä¸ªç”¨æˆ·å¯ä»¥æŸ¥è¯¢ **æ‰€æœ‰é“¾** çš„èµ„äº§ï¼ˆEVM ä½™é¢ + Bitcoin UTXO + Solana Tokenï¼‰
- KV éœ€è¦ **æ ‡è®°é“¾ ID**ï¼Œé¿å…ä¸åŒé“¾çš„åœ°å€å†²çª

## âœ… å½“å‰è®¾è®¡çš„ KV æ ¼å¼

### ç°æœ‰æ–¹æ¡ˆï¼ˆéœ€è¦ä¼˜åŒ–ï¼‰
```rust
// å½“å‰æ ¼å¼ - æ²¡æœ‰é“¾æ ‡è¯†
"account:0x123...:balance"  // âŒ å“ªæ¡é“¾çš„ 0x123ï¼Ÿ
"account:bc1q...:balance"   // âŒ Bitcoin åœ°å€
```

### ä¼˜åŒ–æ–¹æ¡ˆï¼ˆä½ çš„éœ€æ±‚ï¼‰
```rust
// æ–¹æ¡ˆ A: å‰ç¼€åŠ é“¾ ID
"chain:1:account:0x123...:balance"      // Ethereum (chain_id=1)
"chain:56:account:0x123...:balance"     // BSC (chain_id=56)
"chain:900:account:bc1q...:utxo:abc"    // Bitcoin (chain_id=900)
"chain:901:account:11111...:token:SOL"  // Solana (chain_id=901)

// æ–¹æ¡ˆ B: ä½¿ç”¨ ChainType + åœ°å€
"evm:1:0x123...:balance"       // Ethereum
"evm:56:0x123...:balance"      // BSC  
"bitcoin:900:bc1q...:utxo:abc" // Bitcoin
"solana:901:11111...:SOL"      // Solana
```

## ğŸ”§ å®ç°ç»Ÿä¸€æŸ¥è¯¢çš„æ¶æ„

### 1ï¸âƒ£ æ‰©å±• Storage Key æ ¼å¼

```rust
// src/vm-runtime/src/adapter/ir.rs

/// ç»Ÿä¸€çš„å­˜å‚¨é”®æ ¼å¼
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StorageKey {
    /// é“¾ ID (å”¯ä¸€æ ‡è¯†é“¾)
    pub chain_id: u64,
    /// é“¾ç±»å‹
    pub chain_type: ChainType,
    /// è´¦æˆ·åœ°å€
    pub address: Vec<u8>,
    /// å­—æ®µç±»å‹ (balance/nonce/code/storage)
    pub field: StorageField,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum StorageField {
    Balance,
    Nonce,
    Code,
    Storage(Vec<u8>),  // åˆçº¦å­˜å‚¨æ§½
    UTXO(Vec<u8>),     // Bitcoin UTXO ID
    Token(String),     // Solana Token Mint
}

impl StorageKey {
    /// åºåˆ—åŒ–ä¸ºå­—èŠ‚ä¸²
    pub fn to_bytes(&self) -> Vec<u8> {
        format!(
            "chain:{}:{}:{}:{}",
            self.chain_id,
            self.chain_type.as_str(),
            hex::encode(&self.address),
            self.field.as_str()
        ).into_bytes()
    }
    
    /// ä»å­—èŠ‚ä¸²è§£æ
    pub fn from_bytes(data: &[u8]) -> Result<Self> {
        let s = String::from_utf8(data.to_vec())?;
        let parts: Vec<&str> = s.split(':').collect();
        
        if parts.len() < 5 || parts[0] != "chain" {
            bail!("Invalid storage key format");
        }
        
        Ok(Self {
            chain_id: parts[1].parse()?,
            chain_type: ChainType::from_str(parts[2])?,
            address: hex::decode(parts[3])?,
            field: StorageField::from_str(parts[4])?,
        })
    }
}
```

### 2ï¸âƒ£ ç»Ÿä¸€æŸ¥è¯¢ API

```rust
// src/vm-runtime/src/adapter/chain_adapter.rs

pub trait ChainAdapter {
    // ... ç°æœ‰æ–¹æ³• ...
    
    /// è·¨é“¾æŸ¥è¯¢: è·å–ç”¨æˆ·åœ¨æ‰€æœ‰é“¾ä¸Šçš„èµ„äº§
    fn query_all_chains_balance(&self, address: &[u8]) -> Result<MultiChainBalance>;
}

/// å¤šé“¾ä½™é¢èšåˆ
#[derive(Debug, Clone)]
pub struct MultiChainBalance {
    pub total_usd: f64,  // æ€»ä»·å€¼ï¼ˆç¾å…ƒï¼‰
    pub balances: Vec<ChainBalance>,
}

#[derive(Debug, Clone)]
pub struct ChainBalance {
    pub chain_id: u64,
    pub chain_type: ChainType,
    pub native_balance: u128,     // åŸç”Ÿä»£å¸ä½™é¢
    pub tokens: Vec<TokenBalance>, // ERC20/SPL tokens
}

#[derive(Debug, Clone)]
pub struct TokenBalance {
    pub token_address: Vec<u8>,
    pub symbol: String,
    pub balance: u128,
    pub decimals: u8,
}
```

### 3ï¸âƒ£ å®ç°ç»Ÿä¸€æŸ¥è¯¢é€»è¾‘

```rust
// src/vm-runtime/src/adapter/registry.rs

impl AdapterRegistry {
    /// æŸ¥è¯¢ç”¨æˆ·åœ¨æ‰€æœ‰é“¾ä¸Šçš„èµ„äº§ï¼ˆSuperVM æ ¸å¿ƒåŠŸèƒ½ï¼‰
    pub fn query_user_all_assets(&self, address: &[u8]) -> Result<MultiChainBalance> {
        let mut total_balances = MultiChainBalance {
            total_usd: 0.0,
            balances: Vec::new(),
        };
        
        // è·å–æ‰€æœ‰å·²æ³¨å†Œçš„é“¾
        let chain_ids = self.list_chains();
        
        for chain_id in chain_ids {
            // è·å–é€‚é…å™¨
            let adapter = self.get(chain_id)
                .ok_or_else(|| anyhow::anyhow!("Chain {} not found", chain_id))?;
            
            let adapter = adapter.read().unwrap();
            
            // æ„é€ å­˜å‚¨é”®
            let key = StorageKey {
                chain_id,
                chain_type: adapter.chain_type(),
                address: address.to_vec(),
                field: StorageField::Balance,
            };
            
            // æŸ¥è¯¢ä½™é¢
            let balance_bytes = adapter.read_state(&key.to_bytes())?;
            let balance = u128::from_le_bytes(
                balance_bytes[..16].try_into().unwrap_or([0u8; 16])
            );
            
            // æ·»åŠ åˆ°ç»“æœ
            total_balances.balances.push(ChainBalance {
                chain_id,
                chain_type: adapter.chain_type(),
                native_balance: balance,
                tokens: Vec::new(), // TODO: æŸ¥è¯¢ ERC20/SPL tokens
            });
        }
        
        Ok(total_balances)
    }
}
```

## ğŸ“Š ä½¿ç”¨ç¤ºä¾‹ï¼šè·¨é“¾èµ„äº§æŸ¥è¯¢

### åœºæ™¯: ç”¨æˆ·æŸ¥è¯¢è‡ªå·±åœ¨æ‰€æœ‰é“¾ä¸Šçš„èµ„äº§

```rust
// examples/cross_chain_query.rs

use vm_runtime::adapter::{AdapterRegistry, ChainConfig, WasmChainAdapter};

fn main() -> Result<()> {
    let registry = AdapterRegistry::new();
    
    // æ³¨å†Œå¤šä¸ªé“¾
    registry.register(Box::new(EVMAdapter::new(ChainConfig {
        chain_id: 1,      // Ethereum
        name: "Ethereum".into(),
        chain_type: ChainType::EVM,
        ..Default::default()
    })?))?;
    
    registry.register(Box::new(EVMAdapter::new(ChainConfig {
        chain_id: 56,     // BSC
        name: "BSC".into(),
        chain_type: ChainType::EVM,
        ..Default::default()
    })?))?;
    
    registry.register(Box::new(BitcoinAdapter::new(ChainConfig {
        chain_id: 900,    // Bitcoin
        name: "Bitcoin".into(),
        chain_type: ChainType::Bitcoin,
        ..Default::default()
    })?))?;
    
    // ç”¨æˆ·åœ°å€ï¼ˆè·¨é“¾ç»Ÿä¸€èº«ä»½ï¼‰
    let user_address = hex::decode("123456789abcdef...")?;
    
    // ğŸ¯ ç»Ÿä¸€æŸ¥è¯¢æ‰€æœ‰é“¾èµ„äº§
    let assets = registry.query_user_all_assets(&user_address)?;
    
    println!("=== ç”¨æˆ·è·¨é“¾èµ„äº§ ===");
    for balance in assets.balances {
        println!("é“¾: {} (ID: {})", balance.chain_type.as_str(), balance.chain_id);
        println!("  åŸç”Ÿä»£å¸: {} wei/satoshi/lamport", balance.native_balance);
        
        for token in balance.tokens {
            println!("  {} ({}): {}", 
                token.symbol, 
                hex::encode(&token.token_address),
                token.balance
            );
        }
    }
    
    println!("\næ€»ä»·å€¼: ${:.2}", assets.total_usd);
    
    Ok(())
}
```

**è¾“å‡ºç¤ºä¾‹**:
```
=== ç”¨æˆ·è·¨é“¾èµ„äº§ ===
é“¾: EVM (ID: 1)
  åŸç”Ÿä»£å¸: 5000000000000000000 wei (5 ETH)
  USDC (0xA0b8...): 10000000000 (10,000 USDC)
  USDT (0xdAC1...): 5000000000 (5,000 USDT)

é“¾: EVM (ID: 56)
  åŸç”Ÿä»£å¸: 2000000000000000000 wei (2 BNB)
  BUSD (0xe9e7...): 8000000000 (8,000 BUSD)

é“¾: Bitcoin (ID: 900)
  åŸç”Ÿä»£å¸: 50000000 satoshi (0.5 BTC)
  UTXO #abc123: 25000000 satoshi
  UTXO #def456: 25000000 satoshi

é“¾: Solana (ID: 901)
  åŸç”Ÿä»£å¸: 10000000000 lamport (10 SOL)
  USDC (EPjF...): 15000000000 (15,000 USDC)

æ€»ä»·å€¼: $127,450.32
```

## ğŸ” Storage æ•°æ®å®é™…å­˜å‚¨

```rust
// L0.2 RocksDB å®é™…å­˜å‚¨å†…å®¹
Key: "chain:1:evm:0x123456789abcdef:balance"
Value: [0x00, 0x11, 0xc3, 0x7c, 0x29, 0x33, 0x62, 0x00] // 5 ETH in wei

Key: "chain:1:evm:0x123456789abcdef:nonce"
Value: [0x2a, 0x00, 0x00, 0x00] // nonce = 42

Key: "chain:1:evm:0x123456789abcdef:token:0xA0b8...USDC"
Value: [0x00, 0xe8, 0x76, 0x48, 0x17, 0x02, 0x00, 0x00] // 10,000 USDC

Key: "chain:56:evm:0x123456789abcdef:balance"
Value: [0x00, 0x1b, 0xc1, 0x6d, 0x67, 0x4e, 0xc8, 0x00] // 2 BNB

Key: "chain:900:bitcoin:bc1q...xyz:utxo:abc123"
Value: [0x80, 0xf0, 0xfa, 0x02, 0x00, 0x00, 0x00, 0x00] // 0.5 BTC

Key: "chain:901:solana:11111...222:balance"
Value: [0x00, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x00, 0x00] // 10 SOL
```

## ğŸ¯ å…³é”®ä¼˜åŠ¿

### âœ… ä½ æå‡ºçš„ç»Ÿä¸€æŸ¥è¯¢å¥½å¤„

| åŠŸèƒ½ | ä¼ ç»Ÿæ–¹æ¡ˆ | SuperVM æ–¹æ¡ˆ |
|------|---------|--------------|
| **æŸ¥è¯¢ ETH ä½™é¢** | è°ƒç”¨ Infura API | `registry.query_balance(1, addr)` |
| **æŸ¥è¯¢ BNB ä½™é¢** | è°ƒç”¨ BSC RPC | `registry.query_balance(56, addr)` |
| **æŸ¥è¯¢ BTC ä½™é¢** | è°ƒç”¨ Bitcoin Core | `registry.query_balance(900, addr)` |
| **æŸ¥è¯¢æ‰€æœ‰é“¾** | âŒ ä¸å¯èƒ½ | âœ… `query_user_all_assets(addr)` |
| **è·¨é“¾èµ„äº§èšåˆ** | éœ€è¦å‰ç«¯èšåˆ | âœ… SuperVM è‡ªåŠ¨èšåˆ |
| **Gas è´¹ç”¨** | æ¯æ¬¡æŸ¥è¯¢éƒ½è¦ RPC | âœ… ä¸€æ¬¡æŸ¥è¯¢ï¼Œéå† KV |

### âš¡ æ€§èƒ½ä¼˜åŠ¿

```rust
// ä¼ ç»Ÿæ–¹æ¡ˆ: æŸ¥è¯¢ 10 æ¡é“¾éœ€è¦ 10 æ¬¡ RPC è°ƒç”¨
for chain in [ETH, BSC, Polygon, Arbitrum, ...] {
    let balance = rpc_call(chain, address).await?; // 100-500ms æ¯æ¬¡
}
// æ€»è€—æ—¶: 1000-5000ms

// SuperVM æ–¹æ¡ˆ: æœ¬åœ° KV æ‰«æ
let balances = storage.scan("chain:*:*:0x123...:balance")?;
// æ€»è€—æ—¶: 5-20ms âš¡ (200-1000 å€æé€Ÿ)
```

## ğŸš€ å®ç°è®¡åˆ’

æˆ‘ç°åœ¨å¯ä»¥ç«‹å³å®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š

### âœ… ç«‹å³å¯åš
1. **æ‰©å±• StorageKey ç»“æ„** (æ”¯æŒ chain_id å‰ç¼€)
2. **å®ç° `query_user_all_assets()`** (è·¨é“¾èµ„äº§èšåˆ)
3. **æ·»åŠ  Storage æ‰«ææ–¹æ³•** (`scan_prefix()` æ”¯æŒé€šé…ç¬¦)
4. **åˆ›å»ºè·¨é“¾æŸ¥è¯¢ç¤ºä¾‹** (`examples/cross_chain_query.rs`)

### ğŸ“‹ åç»­æ‰©å±•
5. **ä»·æ ¼é¢„è¨€æœºé›†æˆ** (è®¡ç®— `total_usd`)
6. **ERC20/SPL Token æŸ¥è¯¢** (éå† token ä½™é¢)
7. **Web API** (æä¾› HTTP æ¥å£ç»™å‰ç«¯)
8. **ç¼“å­˜å±‚** (Redis åŠ é€Ÿçƒ­ç‚¹æŸ¥è¯¢)

---

## âœ… ä½ çš„ç†è§£ç¡®è®¤

| é—®é¢˜ | ç­”æ¡ˆ | å®ç°æ–¹å¼ |
|------|------|----------|
| **KV éœ€è¦æ ‡è®°å¤–éƒ¨é“¾ï¼Ÿ** | âœ… æ˜¯çš„ | `chain:{chain_id}:{chain_type}:{addr}:{field}` |
| **SuperVM å¯ä»¥æŸ¥è¯¢æ‰€æœ‰é“¾ï¼Ÿ** | âœ… æ˜¯çš„ | `query_user_all_assets()` æ‰«ææ‰€æœ‰ chain_id |
| **ç»Ÿä¸€ KV çš„å¥½å¤„ï¼Ÿ** | âœ… ä¸€æ¬¡æŸ¥è¯¢ï¼Œæ‰€æœ‰èµ„äº§ | é¿å…å¤šæ¬¡ RPCï¼Œæœ¬åœ° KV æ‰«æ |
| **åœ°å€å†²çªï¼Ÿ** | âœ… é¿å… | chain_id å‰ç¼€éš”ç¦»ä¸åŒé“¾ |

---

è¿™å°†æ˜¯ SuperVM çš„ **æ€æ‰‹çº§ç‰¹æ€§**ï¼š
