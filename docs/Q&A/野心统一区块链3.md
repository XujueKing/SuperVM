## ğŸ“Š è·¨é“¾åŠŸèƒ½å±‚çº§åˆ’åˆ†

### æ ¸å¿ƒåŸåˆ™ï¼š**èŒè´£åˆ†ç¦» + æ¸è¿›æŠ½è±¡**

```
L3 (å¤–éƒ¨é€‚é…) â†’ L1 (ç»Ÿä¸€æ¥å£) â†’ L0 (æ ¸å¿ƒæ‰§è¡Œ)
```

---

## ğŸ¯ è¯¦ç»†å±‚çº§åˆ’åˆ†

### 1ï¸âƒ£ **è·¨é“¾æŸ¥è¯¢ (Cross-Chain Query)**

| åŠŸèƒ½ç»„ä»¶ | å±‚çº§ | èŒè´£ | ä»£ç ä½ç½® |
|---------|------|------|----------|
| **æŸ¥è¯¢æ¥å£å®šä¹‰** | **L1.2** | å®šä¹‰ç»Ÿä¸€çš„æŸ¥è¯¢ trait | `adapter/chain_adapter.rs` |
| **æŸ¥è¯¢èšåˆé€»è¾‘** | **L1.2** | è·¨é“¾èµ„äº§èšåˆã€ç»“æœæ ¼å¼åŒ– | `adapter/cross_query.rs` (æ–°å»º) |
| **å…·ä½“é“¾æŸ¥è¯¢** | **L3.2** | å„é“¾çš„æŸ¥è¯¢å®ç° (EVM/Bitcoin/Solana) | `adapters/evm_adapter.rs` |
| **KV å­˜å‚¨è®¿é—®** | **L0.2** | è¯»å–ç»Ÿä¸€ KV æ•°æ® | `storage/storage_trait.rs` |

**å±‚çº§åˆ¤æ–­ä¾æ®**ï¼š
- âœ… **L1.2**: è·¨é“¾èšåˆé€»è¾‘ï¼ˆä¸å…³å¿ƒå…·ä½“æ˜¯å“ªæ¡é“¾ï¼‰
- âœ… **L3.2**: å…·ä½“é“¾çš„æŸ¥è¯¢é€‚é…ï¼ˆçŸ¥é“ EVM/Bitcoin åè®®ç»†èŠ‚ï¼‰
- âœ… **L0.2**: åº•å±‚æ•°æ®è¯»å–ï¼ˆä¸å…³å¿ƒä¸šåŠ¡é€»è¾‘ï¼‰

**ä»£ç ç¤ºä¾‹**ï¼š
```rust
// âœ… L1.2 å±‚ - è·¨é“¾èšåˆ (adapter/cross_query.rs)
pub struct CrossChainQueryService {
    registry: AdapterRegistry,  // L1.2 ç»„ä»¶
}

impl CrossChainQueryService {
    pub fn query_all_assets(&self, address: &[u8]) -> Result<MultiChainAssets> {
        // è¿™é‡Œä¸å…³å¿ƒå…·ä½“æ˜¯ EVM è¿˜æ˜¯ Bitcoin
        // åªè´Ÿè´£èšåˆå„é“¾é€‚é…å™¨çš„ç»“æœ
        for chain_id in self.registry.list_chains() {
            let adapter = self.registry.get(chain_id)?;
            let balance = adapter.read().unwrap().get_balance(address)?;
            // ...
        }
    }
}

// âœ… L3.2 å±‚ - EVM å…·ä½“å®ç° (adapters/evm_adapter.rs)
impl ChainAdapter for EVMAdapter {
    fn get_balance(&self, address: &[u8]) -> Result<u128> {
        // è¿™é‡ŒçŸ¥é“ EVM åè®®ç»†èŠ‚
        let key = format!("chain:{}:evm:{}:balance", 
            self.chain_id, hex::encode(address));
        let value = self.storage.get(&key)?;  // è°ƒç”¨ L0
        Ok(u128::from_le_bytes(value[..16].try_into()?))
    }
}

// âœ… L0.2 å±‚ - å­˜å‚¨è®¿é—® (storage/rocksdb_storage.rs)
impl Storage for RocksDBStorage {
    fn get(&self, key: &[u8]) -> Result<Vec<u8>> {
        // åªè´Ÿè´£è¯»å–ï¼Œä¸å…³å¿ƒä¸šåŠ¡å«ä¹‰
        self.db.get(key)?.ok_or_else(|| anyhow!("Key not found"))
    }
}
```

---

### 2ï¸âƒ£ **è·¨é“¾äº¤æ˜“ (Cross-Chain Transaction)**

| åŠŸèƒ½ç»„ä»¶ | å±‚çº§ | èŒè´£ | ä»£ç ä½ç½® |
|---------|------|------|----------|
| **äº¤æ˜“è·¯ç”±é€»è¾‘** | **L1.2** | åˆ¤æ–­è·¨é“¾ç±»å‹ã€è·¯ç”±åˆ°ç›®æ ‡é“¾ | `adapter/cross_executor.rs` (æ–°å»º) |
| **è·¨é“¾è¯æ˜ç”Ÿæˆ** | **L1.2** | ç”Ÿæˆ Merkle Proofã€çŠ¶æ€è¯æ˜ | `adapter/cross_proof.rs` (æ–°å»º) |
| **TxIR æ‰©å±•** | **L1.2** | æ·»åŠ  `source_chain`, `target_chain` å­—æ®µ | `adapter/ir.rs` (å·²å­˜åœ¨) |
| **å…·ä½“é“¾äº¤æ˜“é€‚é…** | **L3.2** | è§£æ/æ ¼å¼åŒ–å„é“¾äº¤æ˜“æ ¼å¼ | `adapters/evm_adapter.rs` |
| **äº¤æ˜“æ‰§è¡Œ** | **L0.1** | WASM/åŸç”Ÿåˆçº¦æ‰§è¡Œ | `wasm_runtime.rs` |
| **çŠ¶æ€æŒä¹…åŒ–** | **L0.2** | å†™å…¥ KV æ•°æ®åº“ | `storage/rocksdb_storage.rs` |

**å±‚çº§åˆ¤æ–­ä¾æ®**ï¼š
- âœ… **L1.2**: è·¨é“¾é€»è¾‘åè°ƒï¼ˆæºé“¾é”å®š â†’ ç›®æ ‡é“¾é“¸é€ ï¼‰
- âœ… **L3.2**: å…·ä½“é“¾çš„äº¤æ˜“æ ¼å¼è½¬æ¢
- âœ… **L0**: å®é™…æ‰§è¡Œå’Œæ•°æ®æŒä¹…åŒ–

**ä»£ç ç¤ºä¾‹**ï¼š
```rust
// âœ… L1.2 å±‚ - è·¨é“¾æ‰§è¡Œå™¨ (adapter/cross_executor.rs)
pub struct CrossChainExecutor {
    registry: AdapterRegistry,  // L1.2
}

impl CrossChainExecutor {
    pub fn execute_cross_chain_transfer(&self, tx: &TxIR) -> Result<Receipt> {
        // 1. åè°ƒè·¨é“¾æµç¨‹ï¼ˆä¸å…³å¿ƒå…·ä½“åè®®ï¼‰
        let source = self.registry.get(tx.source_chain)?;
        let target = self.registry.get(tx.target_chain)?;
        
        // 2. é”å®šæºé“¾èµ„äº§ï¼ˆè°ƒç”¨ L3 é€‚é…å™¨ï¼‰
        source.read().unwrap().lock_asset(&tx.from, tx.value)?;
        
        // 3. ç”Ÿæˆè·¨é“¾è¯æ˜ï¼ˆL1 é€»è¾‘ï¼‰
        let proof = self.generate_proof(tx)?;
        
        // 4. åœ¨ç›®æ ‡é“¾é“¸é€ ï¼ˆè°ƒç”¨ L3 é€‚é…å™¨ï¼‰
        target.read().unwrap().mint_asset(&tx.to, tx.value, proof)?;
        
        Ok(Receipt { ... })
    }
}

// âœ… L3.2 å±‚ - EVM é€‚é…å™¨ (adapters/evm_adapter.rs)
impl ChainAdapter for EVMAdapter {
    fn lock_asset(&self, address: &[u8], amount: u128) -> Result<()> {
        // çŸ¥é“ EVM çš„å­˜å‚¨æ ¼å¼å’Œè§„åˆ™
        let key = format!("chain:{}:evm:{}:locked", 
            self.chain_id, hex::encode(address));
        self.storage.set(&key, &amount.to_le_bytes())?;  // è°ƒç”¨ L0
        Ok(())
    }
}

// âœ… L0.2 å±‚ - å­˜å‚¨å†™å…¥ (storage/rocksdb_storage.rs)
impl Storage for RocksDBStorage {
    fn set(&self, key: &[u8], value: &[u8]) -> Result<()> {
        // åªè´Ÿè´£å†™å…¥ï¼Œä¸å…³å¿ƒæ˜¯å¦è·¨é“¾
        self.db.put(key, value)?;
        Ok(())
    }
}
```

---

### 3ï¸âƒ£ **è·¨é“¾æ™ºèƒ½åˆçº¦ (Cross-Chain Smart Contracts)**

| åŠŸèƒ½ç»„ä»¶ | å±‚çº§ | èŒè´£ | ä»£ç ä½ç½® |
|---------|------|------|----------|
| **åˆçº¦æ¡¥æ¥é€»è¾‘** | **L1.2** | è·¨é“¾æ¶ˆæ¯ç¼–ç ã€ç»“æœåŒæ­¥ | `adapter/contract_bridge.rs` (æ–°å»º) |
| **WASM è¿è¡Œæ—¶** | **L0.1** | åˆçº¦éƒ¨ç½²ã€æ‰§è¡Œã€Gas è®¡é‡ | `wasm_runtime.rs` (âœ… å·²å®ç°) |
| **Host Functions** | **L0.1** | æä¾›ç»™åˆçº¦çš„ç³»ç»Ÿè°ƒç”¨ | `host_functions.rs` (âœ… å·²å®ç°) |
| **åˆçº¦å­˜å‚¨** | **L0.2** | åˆçº¦ä»£ç å’ŒçŠ¶æ€æŒä¹…åŒ– | `storage/rocksdb_storage.rs` |
| **é“¾ç‰¹å®šè°ƒç”¨** | **L3.2** | EVM/Solana åˆçº¦è°ƒç”¨é€‚é… | `adapters/evm_adapter.rs` |

**å±‚çº§åˆ¤æ–­ä¾æ®**ï¼š
- âœ… **L0.1**: WASM åˆçº¦æ‰§è¡Œï¼ˆä¸é“¾æ— å…³çš„é€šç”¨æ‰§è¡Œå™¨ï¼‰
- âœ… **L1.2**: è·¨é“¾åˆçº¦æ¡¥æ¥ï¼ˆåè°ƒä¸åŒé“¾çš„åˆçº¦è°ƒç”¨ï¼‰
- âœ… **L3.2**: å…·ä½“é“¾çš„åˆçº¦åè®®é€‚é…

**ä»£ç ç¤ºä¾‹**ï¼š
```rust
// âœ… L0.1 å±‚ - WASM è¿è¡Œæ—¶ (wasm_runtime.rs) - å·²å®ç° âœ…
pub struct WasmRuntime {
    engine: Engine,
    store: Store<WasmState>,
    gas_meter: GasMeter,
}

impl WasmRuntime {
    pub fn call_contract(&mut self, addr: &[u8; 32], func: &str, args: &[u8]) 
        -> Result<Vec<u8>> 
    {
        // ä¸é“¾æ— å…³çš„é€šç”¨ WASM æ‰§è¡Œ
        let module = self.load_contract(addr)?;
        let instance = self.linker.instantiate(&mut self.store, &module)?;
        let func = instance.get_func(&mut self.store, func)?;
        // ...
    }
}

// âœ… L1.2 å±‚ - è·¨é“¾åˆçº¦æ¡¥ (adapter/contract_bridge.rs)
pub struct CrossChainContractBridge {
    wasm_runtime: WasmRuntime,  // L0.1
    adapters: AdapterRegistry,   // L1.2
}

impl CrossChainContractBridge {
    pub fn cross_chain_call(
        &mut self,
        source_chain: u64,
        target_chain: u64,
        contract: &[u8; 32],
        function: &str,
        args: &[u8],
    ) -> Result<Vec<u8>> {
        // åè°ƒè·¨é“¾åˆçº¦è°ƒç”¨ï¼ˆä¸å…³å¿ƒå…·ä½“é“¾åè®®ï¼‰
        let source_adapter = self.adapters.get(source_chain)?;
        let target_adapter = self.adapters.get(target_chain)?;
        
        // åœ¨ SuperVM ä¸­æ‰§è¡Œåˆçº¦ï¼ˆè°ƒç”¨ L0ï¼‰
        let result = self.wasm_runtime.call_contract(contract, function, args)?;
        
        // åŒæ­¥ç»“æœåˆ°æºé“¾ï¼ˆè°ƒç”¨ L3ï¼‰
        source_adapter.read().unwrap().sync_result(result)?;
        
        Ok(result)
    }
}

// âœ… L3.2 å±‚ - EVM é€‚é…å™¨ (adapters/evm_adapter.rs)
impl ChainAdapter for EVMAdapter {
    fn sync_result(&self, result: Vec<u8>) -> Result<()> {
        // çŸ¥é“å¦‚ä½•å°†ç»“æœæ ¼å¼åŒ–ä¸º EVM æ ¼å¼
        let eth_receipt = self.format_to_eth_receipt(result)?;
        // è°ƒç”¨ Ethereum RPC
        self.eth_client.send_raw_transaction(eth_receipt)?;
        Ok(())
    }
}
```

---

### 4ï¸âƒ£ **è·¨é“¾æŒ–çŸ¿ (Cross-Chain Mining)**

| åŠŸèƒ½ç»„ä»¶ | å±‚çº§ | èŒè´£ | ä»£ç ä½ç½® |
|---------|------|------|----------|
| **æŒ–çŸ¿æ± ç®¡ç†** | **L1.2** | ç®—åŠ›èšåˆã€å¥–åŠ±åˆ†é…é€»è¾‘ | `consensus/mining_pool.rs` (æ–°å»º) |
| **PoW éªŒè¯** | **L1.2** | é€šç”¨ PoW éªŒè¯é€»è¾‘ | `consensus/pow_verifier.rs` (æ–°å»º) |
| **é“¾ç‰¹å®šæŒ–çŸ¿** | **L3.2** | Bitcoin/Ethereum æŒ–çŸ¿é€‚é… | `adapters/bitcoin_miner.rs` |
| **å…±è¯†æ‰§è¡Œ** | **L0.4** | åŒºå—éªŒè¯ã€çŠ¶æ€è½¬æ¢ | `consensus/` (å¾…è§„åˆ’) |
| **å¥–åŠ±å­˜å‚¨** | **L0.2** | çŸ¿å·¥å¥–åŠ±æŒä¹…åŒ– | `storage/rocksdb_storage.rs` |

**å±‚çº§åˆ¤æ–­ä¾æ®**ï¼š
- âœ… **L1.2**: è·¨é“¾æŒ–çŸ¿åè°ƒï¼ˆç®—åŠ›å½’ä¸€åŒ–ã€å¤šå¸ç§å¥–åŠ±ï¼‰
- âœ… **L3.2**: å…·ä½“é“¾çš„æŒ–çŸ¿åè®®é€‚é…
- âœ… **L0**: å…±è¯†éªŒè¯å’Œæ•°æ®æŒä¹…åŒ–

**ä»£ç ç¤ºä¾‹**ï¼š
```rust
// âœ… L1.2 å±‚ - è·¨é“¾æŒ–çŸ¿æ±  (consensus/mining_pool.rs)
pub struct CrossChainMiningPool {
    adapters: AdapterRegistry,  // L1.2
    reward_calculator: RewardCalculator,
}

impl CrossChainMiningPool {
    pub fn submit_work(&mut self, miner: &[u8], chain_id: u64, nonce: u64) 
        -> Result<MiningReward> 
    {
        // åè°ƒè·¨é“¾æŒ–çŸ¿ï¼ˆä¸å…³å¿ƒå…·ä½“åè®®ï¼‰
        let adapter = self.adapters.get(chain_id)?;
        
        // éªŒè¯ PoWï¼ˆè°ƒç”¨ L3ï¼‰
        let valid = adapter.read().unwrap().verify_pow(nonce)?;
        if !valid {
            bail!("Invalid PoW");
        }
        
        // è®¡ç®—è·¨é“¾å¥–åŠ±ï¼ˆL1 é€»è¾‘ï¼‰
        let reward = self.reward_calculator.allocate(miner, chain_id)?;
        
        // å­˜å‚¨å¥–åŠ±ï¼ˆè°ƒç”¨ L0ï¼‰
        self.save_reward(miner, reward)?;
        
        Ok(reward)
    }
}

// âœ… L3.2 å±‚ - Bitcoin æŒ–çŸ¿é€‚é…å™¨ (adapters/bitcoin_miner.rs)
impl ChainAdapter for BitcoinAdapter {
    fn verify_pow(&self, nonce: u64) -> Result<bool> {
        // çŸ¥é“ Bitcoin çš„ PoW ç®—æ³•ç»†èŠ‚
        let block_hash = self.compute_bitcoin_hash(nonce)?;
        Ok(block_hash < self.target_difficulty)
    }
}

// âœ… L0.2 å±‚ - å¥–åŠ±å­˜å‚¨ (storage/rocksdb_storage.rs)
impl Storage for RocksDBStorage {
    fn set(&self, key: &[u8], value: &[u8]) -> Result<()> {
        // åªè´Ÿè´£å­˜å‚¨ï¼Œä¸å…³å¿ƒæ˜¯æŒ–çŸ¿å¥–åŠ±è¿˜æ˜¯å…¶ä»–
        self.db.put(key, value)?;
        Ok(())
    }
}
```

---

## ğŸ“‹ å±‚çº§èŒè´£æ€»ç»“è¡¨

| å±‚çº§ | èŒè´£ | è·¨é“¾åŠŸèƒ½ | ç‰¹å¾ |
|------|------|----------|------|
| **L3.2 å¤–éƒ¨é€‚é…** | å…·ä½“é“¾åè®®é€‚é… | â€¢ EVM/Bitcoin/Solana å…·ä½“å®ç°<br>â€¢ äº¤æ˜“æ ¼å¼è½¬æ¢<br>â€¢ é“¾ç‰¹å®šæŸ¥è¯¢/æŒ–çŸ¿ | **çŸ¥é“åè®®ç»†èŠ‚** |
| **L1.2 ç»Ÿä¸€æ¥å£** | è·¨é“¾é€»è¾‘åè°ƒ | â€¢ è·¨é“¾æŸ¥è¯¢èšåˆ<br>â€¢ è·¨é“¾äº¤æ˜“è·¯ç”±<br>â€¢ è·¨é“¾åˆçº¦æ¡¥æ¥<br>â€¢ è·¨é“¾æŒ–çŸ¿æ±  | **åè°ƒå¤šé“¾ï¼Œä¸å…³å¿ƒç»†èŠ‚** |
| **L0.1 æ‰§è¡Œå±‚** | é€šç”¨åˆçº¦æ‰§è¡Œ | â€¢ WASM åˆçº¦è¿è¡Œ<br>â€¢ Gas è®¡é‡<br>â€¢ Host Functions | **ä¸é“¾æ— å…³çš„æ‰§è¡Œ** |
| **L0.2 å­˜å‚¨å±‚** | æ•°æ®æŒä¹…åŒ– | â€¢ ç»Ÿä¸€ KV å­˜å‚¨<br>â€¢ MVCC ç‰ˆæœ¬æ§åˆ¶<br>â€¢ RocksDB æŒä¹…åŒ– | **åªå­˜å‚¨ï¼Œä¸å…³å¿ƒä¸šåŠ¡** |

---

## ğŸ¯ å®ç°å»ºè®®ï¼šæ¨¡å—åˆ›å»ºè®¡åˆ’

### L1.2 å±‚æ–°å¢æ¨¡å—ï¼ˆè·¨é“¾æ ¸å¿ƒï¼‰

```rust
src/vm-runtime/src/adapter/
â”œâ”€â”€ chain_adapter.rs       // âœ… å·²å­˜åœ¨
â”œâ”€â”€ ir.rs                  // âœ… å·²å­˜åœ¨
â”œâ”€â”€ registry.rs            // âœ… å·²å­˜åœ¨
â”œâ”€â”€ health.rs              // âœ… å·²å­˜åœ¨
â”œâ”€â”€ cross_query.rs         // â¬œ æ–°å»º - è·¨é“¾æŸ¥è¯¢èšåˆ
â”œâ”€â”€ cross_executor.rs      // â¬œ æ–°å»º - è·¨é“¾äº¤æ˜“æ‰§è¡Œå™¨
â”œâ”€â”€ cross_proof.rs         // â¬œ æ–°å»º - è·¨é“¾è¯æ˜ç”Ÿæˆ
â””â”€â”€ contract_bridge.rs     // â¬œ æ–°å»º - è·¨é“¾åˆçº¦æ¡¥

src/vm-runtime/src/consensus/
â”œâ”€â”€ mining_pool.rs         // â¬œ æ–°å»º - è·¨é“¾æŒ–çŸ¿æ± 
â””â”€â”€ pow_verifier.rs        // â¬œ æ–°å»º - PoW éªŒè¯å™¨
```

### L3.2 å±‚æ–°å¢æ¨¡å—ï¼ˆå…·ä½“é“¾é€‚é…ï¼‰

```rust
src/adapters/                // â¬œ æ–°å»ºç›®å½•
â”œâ”€â”€ evm_adapter.rs           // â¬œ æ–°å»º - EVM é€‚é…å™¨
â”œâ”€â”€ bitcoin_adapter.rs       // â¬œ æ–°å»º - Bitcoin é€‚é…å™¨
â”œâ”€â”€ solana_adapter.rs        // â¬œ æ–°å»º - Solana é€‚é…å™¨
â””â”€â”€ mod.rs
```

---

## âœ… ä½ çš„é—®é¢˜ç­”æ¡ˆ

| è·¨é“¾åŠŸèƒ½ | ä¸»è¦å±‚çº§ | åŸå›  |
|---------|---------|------|
| **è·¨é“¾æŸ¥è¯¢** | **L1.2** | èšåˆé€»è¾‘åœ¨ L1ï¼Œå…·ä½“æŸ¥è¯¢åœ¨ L3 |
| **è·¨é“¾äº¤æ˜“** | **L1.2** | è·¯ç”±å’Œè¯æ˜åœ¨ L1ï¼Œæ‰§è¡Œåœ¨ L0ï¼Œé€‚é…åœ¨ L3 |
| **è·¨é“¾åˆçº¦** | **L0.1 + L1.2** | WASM æ‰§è¡Œåœ¨ L0ï¼Œæ¡¥æ¥åœ¨ L1 |
| **è·¨é“¾æŒ–çŸ¿** | **L1.2** | ç®—åŠ›èšåˆåœ¨ L1ï¼ŒéªŒè¯åœ¨ L3 |

**æ ¸å¿ƒåŸåˆ™**ï¼š
- **L1.2 æ˜¯è·¨é“¾é€»è¾‘çš„å¤§è„‘**ï¼ˆåè°ƒã€èšåˆã€è·¯ç”±ï¼‰
- **L3.2 æ˜¯åè®®é€‚é…çš„æ‰‹è„š**ï¼ˆçŸ¥é“å¦‚ä½•ä¸å„é“¾äº¤äº’ï¼‰
- **L0 æ˜¯æ‰§è¡Œå’Œå­˜å‚¨çš„å¿ƒè„**ï¼ˆä¸å…³å¿ƒä¸šåŠ¡ï¼Œåªè´Ÿè´£æ‰§è¡Œå’ŒæŒä¹…åŒ–ï¼‰

---

